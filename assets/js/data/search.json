[ { "title": "安卓百度加固脱壳还原记录", "url": "/posts/%E5%AE%89%E5%8D%93%E7%99%BE%E5%BA%A6%E5%8A%A0%E5%9B%BA%E8%84%B1%E5%A3%B3%E8%BF%98%E5%8E%9F%E8%AE%B0%E5%BD%95/", "categories": "逆向记录", "tags": "Android, 逆向", "date": "2024-12-27 11:13:20 +0800", "snippet": "使用的工具 BlackDex MT管理器 jadx提取安装包使用BlackDex脱壳使用`MT管理器对比删除文件1、删除百度加固文件assets目录下lib/arm64-v8a目录下对比原apk中的dex文件 把脱壳出来的跟原apk中大小一致的删掉3、使用jdax-ui打开脱壳出来的dex文件 把包含sagittarius包名所在的dex文件删除4、重命名脱壳出来的dex文件5、修复脱壳出来的dex文件6、添加到原apk中7、替换中AndroidManifest.xml的应用程序入口使用jadx-gui打开未脱壳的apk文件搜索AppInfo类获取应用程序原始入口替换AndroidManifest.xml中的com.sagittarius.v6.StubApplication为上面获取的原始入口重签名安装" }, { "title": "iOS中Flutter应用逆向方法", "url": "/posts/iOS%E4%B8%ADFlutter%E5%BA%94%E7%94%A8%E9%80%86%E5%90%91%E6%96%B9%E6%B3%95/", "categories": "逆向记录", "tags": "iOS, Flutter, 逆向", "date": "2024-07-17 16:32:21 +0800", "snippet": "安装reflutter 参考地址：reFlutterpip3 install reflutter使用# 重打包 完成后重签名后安装到iOS设备上即可reflutter xxx.ipa使用Charles抓包Charles监听端口设置为8083即可查看dump出的dart文件重签名安装后将iOS设备连接到Mac上，可在macOS的控制台看到iOS设备的实时日志。增加过滤条件Current working dir:即可。例如：/private/var/mobile/Containers/Data/Application/&amp;lt;UUID&amp;gt;/dump.dart" }, { "title": "iOS越狱deb插件重打包", "url": "/posts/iOS%E8%B6%8A%E7%8B%B1deb%E6%8F%92%E4%BB%B6%E9%87%8D%E6%89%93%E5%8C%85/", "categories": "逆向记录", "tags": "iOS，越狱, 逆向", "date": "2024-07-07 14:14:20 +0800", "snippet": "解压mkdir packagedpkg -x xxx.deb ./packagedpkg -e xxx.deb ./package/DEBIAN压缩dpkg-deb -b ./package xxx_new.deb" }, { "title": "Cocos2d-Lua手游逆向记录", "url": "/posts/Cocos2d-Lua%E6%89%8B%E6%B8%B8%E9%80%86%E5%90%91%E8%AE%B0%E5%BD%95/", "categories": "逆向记录", "tags": "cocos2d，lua, 手游, 逆向", "date": "2023-07-24 14:14:20 +0800", "snippet": "Lua5.1luaL_loadbuffer函数原型LUALIB_API int luaL_loadbuffer (lua_State *L, const char *buff, size_t size, const char *name) { LoadS ls; ls.s = buff; ls.size = size; return lua_load(L, getS, &amp;amp;ls, name);}特征码FF 83 00 D1 FD 7B 01 A9 FD 43 00 91 E1 0B 00 A9 ?? ?? ?? ?? ?? ?? ?? ?? E2 03 00 91 ?? ?? ?? ?? FDluaU_undump函数原型/*** load precompiled chunk*/Proto *luaU_undump(lua_State *L, ZIO *Z, Mbuffer *buff, const char *name){ LoadState S; if (*name == &#39;@&#39; || *name == &#39;=&#39;) S.name = name + 1; else if (*name == LUA_SIGNATURE[0]) S.name = &quot;binary string&quot;; else S.name = name; S.L = L; S.Z = Z; S.b = buff; LoadHeader(&amp;amp;S); return LoadFunction(&amp;amp;S, luaS_newliteral(L, &quot;=?&quot;));}特征码 &quot;binary string&quot;交叉引用FF 43 02 D1 F6 57 06 A9 F4 4F 07 A9 FD 7B 08 A9 FD 03 02 91 F5 03 01 AA F3 03 00 AA ?? ?? ?? ?? 08luaV_execute函数原型void luaV_execute (lua_State *L, int nexeccalls) { LClosure *cl; StkId base; TValue *k; const Instruction *pc; reentry: /* entry point */ pc = L-&amp;gt;savedpc; cl = &amp;amp;clvalue(L-&amp;gt;ci-&amp;gt;func)-&amp;gt;l; base = L-&amp;gt;base; k = cl-&amp;gt;p-&amp;gt;k; /* main loop of interpreter */ for (;;) { const Instruction i = *pc++; StkId ra; if ((L-&amp;gt;hookmask &amp;amp; (LUA_MASKLINE | LUA_MASKCOUNT)) &amp;amp;&amp;amp; (--L-&amp;gt;hookcount == 0 || L-&amp;gt;hookmask &amp;amp; LUA_MASKLINE)) { traceexec(L, pc); if (L-&amp;gt;status == LUA_YIELD) { /* did hook yield? */ L-&amp;gt;savedpc = pc - 1; return; } base = L-&amp;gt;base; } /* warning!! several calls may realloc the stack and invalidate `ra&#39; */ ra = RA(i); lua_assert(base == L-&amp;gt;base &amp;amp;&amp;amp; L-&amp;gt;base == L-&amp;gt;ci-&amp;gt;base); lua_assert(base &amp;lt;= L-&amp;gt;top &amp;amp;&amp;amp; L-&amp;gt;top &amp;lt;= L-&amp;gt;stack + L-&amp;gt;stacksize); lua_assert(L-&amp;gt;top == L-&amp;gt;ci-&amp;gt;top || luaG_checkopenop(i)); switch (GET_OPCODE(i)) { case OP_MOVE: { setobjs2s(L, ra, RB(i)); continue; } case OP_LOADK: { setobj2s(L, ra, KBx(i)); continue; } case OP_LOADBOOL: { setbvalue(ra, GETARG_B(i)); if (GETARG_C(i)) pc++; /* skip next instruction (if C) */ continue; } case OP_LOADNIL: { TValue *rb = RB(i); do { setnilvalue(rb--); } while (rb &amp;gt;= ra); continue; } case OP_GETUPVAL: { int b = GETARG_B(i); setobj2s(L, ra, cl-&amp;gt;upvals[b]-&amp;gt;v); continue; } case OP_GETGLOBAL: { TValue g; TValue *rb = KBx(i); sethvalue(L, &amp;amp;g, cl-&amp;gt;env); lua_assert(ttisstring(rb)); Protect(luaV_gettable(L, &amp;amp;g, rb, ra)); continue; } case OP_GETTABLE: { Protect(luaV_gettable(L, RB(i), RKC(i), ra)); continue; } case OP_SETGLOBAL: { TValue g; sethvalue(L, &amp;amp;g, cl-&amp;gt;env); lua_assert(ttisstring(KBx(i))); Protect(luaV_settable(L, &amp;amp;g, KBx(i), ra)); continue; } case OP_SETUPVAL: { UpVal *uv = cl-&amp;gt;upvals[GETARG_B(i)]; setobj(L, uv-&amp;gt;v, ra); luaC_barrier(L, uv, ra); continue; } case OP_SETTABLE: { Protect(luaV_settable(L, ra, RKB(i), RKC(i))); continue; } case OP_NEWTABLE: { int b = GETARG_B(i); int c = GETARG_C(i); sethvalue(L, ra, luaH_new(L, luaO_fb2int(b), luaO_fb2int(c))); Protect(luaC_checkGC(L)); continue; } case OP_SELF: { StkId rb = RB(i); setobjs2s(L, ra+1, rb); Protect(luaV_gettable(L, rb, RKC(i), ra)); continue; } case OP_ADD: { arith_op(luai_numadd, TM_ADD); continue; } case OP_SUB: { arith_op(luai_numsub, TM_SUB); continue; } case OP_MUL: { arith_op(luai_nummul, TM_MUL); continue; } case OP_DIV: { arith_op(luai_numdiv, TM_DIV); continue; } case OP_MOD: { arith_op(luai_nummod, TM_MOD); continue; } case OP_POW: { arith_op(luai_numpow, TM_POW); continue; } case OP_UNM: { TValue *rb = RB(i); if (ttisnumber(rb)) { lua_Number nb = nvalue(rb); setnvalue(ra, luai_numunm(nb)); } else { Protect(Arith(L, ra, rb, rb, TM_UNM)); } continue; } case OP_NOT: { int res = l_isfalse(RB(i)); /* next assignment may change this value */ setbvalue(ra, res); continue; } case OP_LEN: { const TValue *rb = RB(i); switch (ttype(rb)) { case LUA_TTABLE: { setnvalue(ra, cast_num(luaH_getn(hvalue(rb)))); break; } case LUA_TSTRING: { setnvalue(ra, cast_num(tsvalue(rb)-&amp;gt;len)); break; } default: { /* try metamethod */ Protect( if (!call_binTM(L, rb, luaO_nilobject, ra, TM_LEN)) luaG_typeerror(L, rb, &quot;get length of&quot;); ) } } continue; } case OP_CONCAT: { int b = GETARG_B(i); int c = GETARG_C(i); Protect(luaV_concat(L, c-b+1, c); luaC_checkGC(L)); setobjs2s(L, RA(i), base+b); continue; } case OP_JMP: { dojump(L, pc, GETARG_sBx(i)); continue; } case OP_EQ: { TValue *rb = RKB(i); TValue *rc = RKC(i); Protect( if (equalobj(L, rb, rc) == GETARG_A(i)) dojump(L, pc, GETARG_sBx(*pc)); ) pc++; continue; } case OP_LT: { Protect( if (luaV_lessthan(L, RKB(i), RKC(i)) == GETARG_A(i)) dojump(L, pc, GETARG_sBx(*pc)); ) pc++; continue; } case OP_LE: { Protect( if (lessequal(L, RKB(i), RKC(i)) == GETARG_A(i)) dojump(L, pc, GETARG_sBx(*pc)); ) pc++; continue; } case OP_TEST: { if (l_isfalse(ra) != GETARG_C(i)) dojump(L, pc, GETARG_sBx(*pc)); pc++; continue; } case OP_TESTSET: { TValue *rb = RB(i); if (l_isfalse(rb) != GETARG_C(i)) { setobjs2s(L, ra, rb); dojump(L, pc, GETARG_sBx(*pc)); } pc++; continue; } case OP_CALL: { int b = GETARG_B(i); int nresults = GETARG_C(i) - 1; if (b != 0) L-&amp;gt;top = ra+b; /* else previous instruction set top */ L-&amp;gt;savedpc = pc; switch (luaD_precall(L, ra, nresults)) { case PCRLUA: { nexeccalls++; goto reentry; /* restart luaV_execute over new Lua function */ } case PCRC: { /* it was a C function (`precall&#39; called it); adjust results */ if (nresults &amp;gt;= 0) L-&amp;gt;top = L-&amp;gt;ci-&amp;gt;top; base = L-&amp;gt;base; continue; } default: { return; /* yield */ } } } case OP_TAILCALL: { int b = GETARG_B(i); if (b != 0) L-&amp;gt;top = ra+b; /* else previous instruction set top */ L-&amp;gt;savedpc = pc; lua_assert(GETARG_C(i) - 1 == LUA_MULTRET); switch (luaD_precall(L, ra, LUA_MULTRET)) { case PCRLUA: { /* tail call: put new frame in place of previous one */ CallInfo *ci = L-&amp;gt;ci - 1; /* previous frame */ int aux; StkId func = ci-&amp;gt;func; StkId pfunc = (ci+1)-&amp;gt;func; /* previous function index */ if (L-&amp;gt;openupval) luaF_close(L, ci-&amp;gt;base); L-&amp;gt;base = ci-&amp;gt;base = ci-&amp;gt;func + ((ci+1)-&amp;gt;base - pfunc); for (aux = 0; pfunc+aux &amp;lt; L-&amp;gt;top; aux++) /* move frame down */ setobjs2s(L, func+aux, pfunc+aux); ci-&amp;gt;top = L-&amp;gt;top = func+aux; /* correct top */ lua_assert(L-&amp;gt;top == L-&amp;gt;base + clvalue(func)-&amp;gt;l.p-&amp;gt;maxstacksize); ci-&amp;gt;savedpc = L-&amp;gt;savedpc; ci-&amp;gt;tailcalls++; /* one more call lost */ L-&amp;gt;ci--; /* remove new frame */ goto reentry; } case PCRC: { /* it was a C function (`precall&#39; called it) */ base = L-&amp;gt;base; continue; } default: { return; /* yield */ } } } case OP_RETURN: { int b = GETARG_B(i); if (b != 0) L-&amp;gt;top = ra+b-1; if (L-&amp;gt;openupval) luaF_close(L, base); L-&amp;gt;savedpc = pc; b = luaD_poscall(L, ra); if (--nexeccalls == 0) /* was previous function running `here&#39;? */ return; /* no: return */ else { /* yes: continue its execution */ if (b) L-&amp;gt;top = L-&amp;gt;ci-&amp;gt;top; lua_assert(isLua(L-&amp;gt;ci)); lua_assert(GET_OPCODE(*((L-&amp;gt;ci)-&amp;gt;savedpc - 1)) == OP_CALL); goto reentry; } } case OP_FORLOOP: { lua_Number step = nvalue(ra+2); lua_Number idx = luai_numadd(nvalue(ra), step); /* increment index */ lua_Number limit = nvalue(ra+1); if (luai_numlt(0, step) ? luai_numle(idx, limit) : luai_numle(limit, idx)) { dojump(L, pc, GETARG_sBx(i)); /* jump back */ setnvalue(ra, idx); /* update internal index... */ setnvalue(ra+3, idx); /* ...and external index */ } continue; } case OP_FORPREP: { const TValue *init = ra; const TValue *plimit = ra+1; const TValue *pstep = ra+2; L-&amp;gt;savedpc = pc; /* next steps may throw errors */ if (!tonumber(init, ra)) luaG_runerror(L, LUA_QL(&quot;for&quot;) &quot; initial value must be a number&quot;); else if (!tonumber(plimit, ra+1)) luaG_runerror(L, LUA_QL(&quot;for&quot;) &quot; limit must be a number&quot;); else if (!tonumber(pstep, ra+2)) luaG_runerror(L, LUA_QL(&quot;for&quot;) &quot; step must be a number&quot;); setnvalue(ra, luai_numsub(nvalue(ra), nvalue(pstep))); dojump(L, pc, GETARG_sBx(i)); continue; } case OP_TFORLOOP: { StkId cb = ra + 3; /* call base */ setobjs2s(L, cb+2, ra+2); setobjs2s(L, cb+1, ra+1); setobjs2s(L, cb, ra); L-&amp;gt;top = cb+3; /* func. + 2 args (state and index) */ Protect(luaD_call(L, cb, GETARG_C(i))); L-&amp;gt;top = L-&amp;gt;ci-&amp;gt;top; cb = RA(i) + 3; /* previous call may change the stack */ if (!ttisnil(cb)) { /* continue loop? */ setobjs2s(L, cb-1, cb); /* save control variable */ dojump(L, pc, GETARG_sBx(*pc)); /* jump back */ } pc++; continue; } case OP_SETLIST: { int n = GETARG_B(i); int c = GETARG_C(i); int last; Table *h; if (n == 0) { n = cast_int(L-&amp;gt;top - ra) - 1; L-&amp;gt;top = L-&amp;gt;ci-&amp;gt;top; } if (c == 0) c = cast_int(*pc++); runtime_check(L, ttistable(ra)); h = hvalue(ra); last = ((c-1)*LFIELDS_PER_FLUSH) + n; if (last &amp;gt; h-&amp;gt;sizearray) /* needs more space? */ luaH_resizearray(L, h, last); /* pre-alloc it at once */ for (; n &amp;gt; 0; n--) { TValue *val = ra+n; setobj2t(L, luaH_setnum(L, h, last--), val); luaC_barriert(L, h, val); } continue; } case OP_CLOSE: { luaF_close(L, ra); continue; } case OP_CLOSURE: { Proto *p; Closure *ncl; int nup, j; p = cl-&amp;gt;p-&amp;gt;p[GETARG_Bx(i)]; nup = p-&amp;gt;nups; ncl = luaF_newLclosure(L, nup, cl-&amp;gt;env); ncl-&amp;gt;l.p = p; for (j=0; j&amp;lt;nup; j++, pc++) { if (GET_OPCODE(*pc) == OP_GETUPVAL) ncl-&amp;gt;l.upvals[j] = cl-&amp;gt;upvals[GETARG_B(*pc)]; else { lua_assert(GET_OPCODE(*pc) == OP_MOVE); ncl-&amp;gt;l.upvals[j] = luaF_findupval(L, base + GETARG_B(*pc)); } } setclvalue(L, ra, ncl); Protect(luaC_checkGC(L)); continue; } case OP_VARARG: { int b = GETARG_B(i) - 1; int j; CallInfo *ci = L-&amp;gt;ci; int n = cast_int(ci-&amp;gt;base - ci-&amp;gt;func) - cl-&amp;gt;p-&amp;gt;numparams - 1; if (b == LUA_MULTRET) { Protect(luaD_checkstack(L, n)); ra = RA(i); /* previous call may change the stack */ b = n; L-&amp;gt;top = ra + n; } for (j = 0; j &amp;lt; b; j++) { if (j &amp;lt; n) { setobjs2s(L, ra + j, ci-&amp;gt;base - n + j); } else { setnilvalue(ra + j); } } continue; } } }}特征码 交叉引用字符串&#39;for&#39; step must be a numberFF 03 02 D1 FC 6F 02 A9 FA 67 03 A9 F8 5F 04 A9 F6 57 05 A9 F4 4F 06 A9 FD 7B 07 A9 FD C3 01 91 E1 07 ?? ?? F3 03 00 AA 68 EE 42 A9xxtea_decrypt使用// decrypt XXTEAxxtea_long len = 0;unsigned char *result = xxtea_decrypt((unsigned char *)chunk + _xxteaSignLen, (xxtea_long)chunkSize - _xxteaSignLen, (unsigned char *)_xxteaKey, (xxtea_long)_xxteaKeyLen, &amp;amp;len);特征码FA 67 BB A9 F8 5F 01 A9 F6 57 02 A9 F4 4F 03 A9 FD 7B 04 A9 FD 03 01 91 F3 03 04 AA F7 03 02 AA F4" }, { "title": "加密算法特征", "url": "/posts/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E7%89%B9%E5%BE%81/", "categories": "加解密", "tags": "加解密，算法特征", "date": "2023-07-11 11:28:20 +0800", "snippet": "SHA256int crypto_hash_sha256_init(crypto_hash_sha256_state *state){ // 大常数 static const uint32_t sha256_initial_state[8] = { 0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19 }; state-&amp;gt;count = (uint64_t) 0U; memcpy(state-&amp;gt;state, sha256_initial_state, sizeof sha256_initial_state); return 0;}int crypto_hash_sha256_update(crypto_hash_sha256_state *state, const unsigned char *in, unsigned long long inlen){ uint32_t tmp32[64 + 8]; unsigned long long i; unsigned long long r; if (inlen &amp;lt;= 0U) { return 0; } ACQUIRE_FENCE; r = (unsigned long long) ((state-&amp;gt;count &amp;gt;&amp;gt; 3) &amp;amp; 0x3f); state-&amp;gt;count += ((uint64_t) inlen) &amp;lt;&amp;lt; 3; if (inlen &amp;lt; 64 - r) { for (i = 0; i &amp;lt; inlen; i++) { state-&amp;gt;buf[r + i] = in[i]; } return 0; } for (i = 0; i &amp;lt; 64 - r; i++) { state-&amp;gt;buf[r + i] = in[i]; } SHA256_Transform(state-&amp;gt;state, state-&amp;gt;buf, &amp;amp;tmp32[0], &amp;amp;tmp32[64]); in += 64 - r; inlen -= 64 - r; while (inlen &amp;gt;= 64) { SHA256_Transform(state-&amp;gt;state, in, &amp;amp;tmp32[0], &amp;amp;tmp32[64]); in += 64; inlen -= 64; } inlen &amp;amp;= 63; for (i = 0; i &amp;lt; inlen; i++) { state-&amp;gt;buf[i] = in[i]; } sodium_memzero((void *) tmp32, sizeof tmp32); return 0;}int crypto_hash_sha256_final(crypto_hash_sha256_state *state, unsigned char *out){ uint32_t tmp32[64 + 8]; SHA256_Pad(state, tmp32); be32enc_vect(out, state-&amp;gt;state, 32); sodium_memzero((void *) tmp32, sizeof tmp32); sodium_memzero((void *) state, sizeof *state); return 0;}int crypto_hash_sha256(unsigned char *out, const unsigned char *in, unsigned long long inlen){ crypto_hash_sha256_state state; crypto_hash_sha256_init(&amp;amp;state); crypto_hash_sha256_update(&amp;amp;state, in, inlen); crypto_hash_sha256_final(&amp;amp;state, out); return 0;}" }, { "title": "非越狱下InlineHook方案", "url": "/posts/%E9%9D%9E%E8%B6%8A%E7%8B%B1%E4%B8%8BInlineHook%E6%96%B9%E6%A1%88/", "categories": "逆向技术", "tags": "iOS逆向", "date": "2023-07-05 18:40:20 +0800", "snippet": "使用MachOStaticPatcher静态修改Mach-O文件。1、编译 &amp;amp; Patch1、下载MachOStaticPatcher# 下载wget --no-check-certificate --content-disposition https://github.com/jmpews/Dobby/archive/793b9c3bd11d7666eb8ca186e2ddea7072f92f73.zip# 解压unzip Dobby-793b9c3bd11d7666eb8ca186e2ddea7072f92f73.zip2、编译# 编译MachOStaticPatchercd Dobby-793b9c3bd11d7666eb8ca186e2ddea7072f92f73/Plugins/MachOStaticPatchermkdir build &amp;amp;&amp;amp; cd buildcmake .. -DHOOKZZ_SOURCE_DIR=../../../make -j43、修改Mach-O文件# 移除签名codesign --remove-signature ./xxxx.app/# 静态Patch 支持一次patch多个C函数地址./MachOStaticPatcher ./xxxx.app/xxxx C函数地址1 C函数地址2# 重命名rm ./xxxx.app/xxxxmv ./xxxx.app/xxxx_modified ./xxxx.app/xxxx# 重签名codesign --force --sign xxx ./xxxx.app/2、MonkeyDev适配 修改pack.sh脚本内容1、修改签名部分# &quot;$MONKEYPARSER&quot; install -c load -p &quot;@executable_path/Frameworks/lib&quot;&quot;${TARGET_NAME}&quot;&quot;Dylib.dylib&quot; -t &quot;${BUILD_APP_PATH}/${APP_BINARY}&quot;# 修改为 optoolOPTOOL=&quot;/usr/local/bin/optool&quot;echo &quot;xxxx&quot; | sudo -S &quot;$OPTOOL&quot; install -c load -p &quot;@executable_path/Frameworks/lib&quot;&quot;${TARGET_NAME}&quot;&quot;Dylib.dylib&quot; -t &quot;${BUILD_APP_PATH}/${APP_BINARY}&quot;2、修改checkApp方法# 注释以下代码# if [[ $? -eq 16 ]]; then# panic 1 &quot;${VERIFY_RESULT}&quot;# else# echo &quot;${VERIFY_RESULT}&quot;# fi3、Hook对应的C函数 把InterfaceInternal.h、TrampolineStubRebase.cc、FunctionInlineReplaceExport.cc添加到MonkeyDev工程内#include &quot;InterfaceInternal.h&quot;// 原始C函数static int (*sub_1001471B8)(intptr_t L_ptr);// 自己的C函数static int replaced_sub_1001471B8(intptr_t L_ptr) { return sub_1001471B8(L_ptr);}CHConstructor{ // Hook对应的C函数 ZzReplaceStatic((char *)&quot;模块名称&quot;, (void *)0x1001471B8, (void *)&amp;amp;replaced_sub_1001471B8, (void **)&amp;amp;sub_1001471B8);}4、参考MachOStaticPatcher" }, { "title": "Python全局安装依赖", "url": "/posts/Python%E5%85%A8%E5%B1%80%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96/", "categories": "Python", "tags": "Python", "date": "2023-06-21 10:00:20 +0800", "snippet": "python3 -m pip install numpy" }, { "title": "M系列Mac安装cocoapods", "url": "/posts/M%E7%B3%BB%E5%88%97Mac%E5%AE%89%E8%A3%85cocoapods/", "categories": "iOS开发", "tags": "iOS开发", "date": "2023-06-01 10:00:20 +0800", "snippet": "安装sudo gem install cocoapods -n /usr/local/bin" }, { "title": "OLLVM混淆去除", "url": "/posts/OLLVM%E6%B7%B7%E6%B7%86%E5%A4%84%E7%90%86/", "categories": "逆向技术", "tags": "macOS逆向, ollvm, IDA Pro", "date": "2023-03-16 22:48:20 +0800", "snippet": "安装d810 下载git clone https://gitlab.com/eshard/d810.gitpip3 install z3-solver 安装 拷贝d810、d810.py到IDA Pro的安装目录中的plugins文件夹下 使用 打开IDA，载入样本 xxx， 然后 File→Script File… 选中 D810.py 跑一下，最后 Ctrl-Shift-D就会出现结果,点击start即可执行F5。 " }, { "title": "Swift与OC混编问题汇总", "url": "/posts/Swift%E4%B8%8EOC%E6%B7%B7%E7%BC%96%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/", "categories": "iOS开发", "tags": "iOS开发, Swift, objective-c", "date": "2023-03-16 22:28:20 +0800", "snippet": "1、找不到第三方库中的文件import顺序需要遵循 [系统库-&amp;gt;第三方库-&amp;gt;自己内部组件] 2、其它问题" }, { "title": "iOS Development Tips", "url": "/posts/iOS-Development-Tips/", "categories": "iOS, Development", "tags": "iOS, Swift", "date": "2022-11-18 14:18:20 +0800", "snippet": "Swift应用交叉编译swift build -c release --arch arm64 --arch x86_64解决使用旧版本Xcode打包二进制库，Swift编译的问题 Build Setting中BUILD_LIBRARY_FOR_DISTRIBUTION改为YES使用xcrun atos解析crash日志xcrun atos -o xxx.app.dSYM/Contents/Resources/DWARF/xxx -arch arm64 -l 模块基地址 模块内内存地址" }, { "title": "Rust应用交叉编译", "url": "/posts/Rust%E5%BA%94%E7%94%A8%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/", "categories": "Rust, Development", "tags": "Rust", "date": "2022-11-15 18:28:20 +0800", "snippet": "Rust应用交叉编译 安装架构 rustup target install x86_64-apple-darwin 编译 cargo build --target x86_64-apple-darwin 使用配置文件.cargo/config.toml [build]target = [&quot;aarch64-apple-darwin&quot;, &quot;x86_64-apple-darwin&quot;] " }, { "title": "XMind逆向记录", "url": "/posts/XMind%E9%80%86%E5%90%91%E8%AE%B0%E5%BD%95/", "categories": "", "tags": "macOS逆向", "date": "2022-07-28 16:00:30 +0800", "snippet": "0x1 安装asar解压工具 npm install -g asar 解压app.asar文件 mkdir app &amp;amp;&amp;amp; asar e app.asar ./app 0x2 修改computeSubscriptionStatus方法 computeSubscriptionStatus: (e) =&amp;gt; (t) =&amp;gt; s.ACTIVATION_STATUS.VALID, 修改status 方法 status: (e, t) =&amp;gt; s.ACTIVATION_STATUS.VALID, 屏蔽自动更新 t.canAutoUpdater = !1; 0x3 打包 asar pack ./app/ app.asar " }, { "title": "Mac安装sshpass", "url": "/posts/Mac%E5%AE%89%E8%A3%85sshpass/", "categories": "", "tags": "iOS, 越狱插件开发", "date": "2022-07-05 00:00:00 +0800", "snippet": "下载 &amp;amp;&amp;amp; 解压https://sourceforge.net/projects/sshpass/编译 &amp;amp;&amp;amp; 安装./configure &amp;amp;&amp;amp; make &amp;amp;&amp;amp; make install" }, { "title": "OLLVM混淆初探-编译安装", "url": "/posts/OLLVM%E6%B7%B7%E6%B7%86%E5%88%9D%E6%8E%A2-%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85/", "categories": "LLVM", "tags": "LLVM, OLLVM混淆", "date": "2022-06-06 23:00:20 +0800", "snippet": "macOS 编译安装cd ~/Desktop &amp;amp;&amp;amp; mkdir llvmcd llvmwget https://heroims.github.io/obfuscator/NewPass/ollvm14.patchgit clone -b release/14.x git@github.com:llvm/llvm-project.gitcd llvm-projectgit apply ../ollvm14.patchgit apply --reject --ignore-whitespace ../ollvm14.patchcd ..mkdir buildcd buildcmake -DCMAKE_BUILD_TYPE=Release -DLLVM_CREATE_XCODE_TOOLCHAIN=ON -DLLVM_ENABLE_PROJECTS=&quot;clang;libcxx;libcxxabi&quot; ../llvm-project/llvmmake -j7sudo make install-xcode-toolchainmv /usr/local/Toolchains /Library/Developer/" }, { "title": "Mac应用LaunchServices服务Patch", "url": "/posts/Mac%E5%BA%94%E7%94%A8LaunchServices%E6%9C%8D%E5%8A%A1Patch/", "categories": "逆向技术", "tags": "macOS逆向, iOS逆向", "date": "2022-06-04 23:20:00 +0800", "snippet": "0x1 查看架构 lipo -info com.xxxx.Agent 分离架构 lipo com.xxx.Agent -thin x86_64 -output com.xxx.Agent_x86_64lipo com.xxx.Agent -thin arm64 -output com.xxx.Agent_arm64 0x2 Patch对应架构的LaunchServices0x3 使用010 Editor或者UE打开对应架构的LaunchServices文件 查找SMAuthorizedClients字段 修改对应的值只留 identifier “com.macpaw.CleanMyMac4.HealthMonitor” 字段 记录上一步所删除的值的长度 在&amp;lt;/dict&amp;gt;.&amp;lt;/plist&amp;gt;后面插入删除值的长度 把新插入的值修改为0A 保存0x4 合并多架构LaunchServices lipo -create com.xxx.Agent_arm64 com.xxx.Agent_x86_64 -output com.xxxx.Agent 重签名 codesign -f -s &quot;证书&quot; com.xxxx.Agent 检查LaunchServices签名状态 codesign -v -v com.xxx.Agent 0x5 修改主程序的Info.plist的Tools owned after installation字段 重签名主程序 codesign -f -s &quot;证书&quot; --deep --no-strict xxx.app 0x6 验证LaunchServices的合法性 python SMJobBlessUtil.py check xxx.app SMJobBlessUtil.py 代码 #! /usr/bin/python3## File: SMJobBlessUtil.py## Contains: Tool for checking and correcting apps that use SMJobBless.## Written by: DTS## Copyright: Copyright (c) 2012 Apple Inc. All Rights Reserved.## Disclaimer: IMPORTANT: This Apple software is supplied to you by Apple Inc.# (&quot;Apple&quot;) in consideration of your agreement to the following# terms, and your use, installation, modification or# redistribution of this Apple software constitutes acceptance of# these terms. If you do not agree with these terms, please do# not use, install, modify or redistribute this Apple software.## In consideration of your agreement to abide by the following# terms, and subject to these terms, Apple grants you a personal,# non-exclusive license, under Apple&#39;s copyrights in this# original Apple software (the &quot;Apple Software&quot;), to use,# reproduce, modify and redistribute the Apple Software, with or# without modifications, in source and/or binary forms; provided# that if you redistribute the Apple Software in its entirety and# without modifications, you must retain this notice and the# following text and disclaimers in all such redistributions of# the Apple Software. Neither the name, trademarks, service marks# or logos of Apple Inc. may be used to endorse or promote# products derived from the Apple Software without specific prior# written permission from Apple. Except as expressly stated in# this notice, no other rights or licenses, express or implied,# are granted by Apple herein, including but not limited to any# patent rights that may be infringed by your derivative works or# by other works in which the Apple Software may be incorporated.## The Apple Software is provided by Apple on an &quot;AS IS&quot; basis.# APPLE MAKES NO WARRANTIES, EXPRESS OR IMPLIED, INCLUDING# WITHOUT LIMITATION THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, REGARDING# THE APPLE SOFTWARE OR ITS USE AND OPERATION ALONE OR IN# COMBINATION WITH YOUR PRODUCTS.## IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT,# INCIDENTAL OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED# TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) ARISING IN ANY WAY# OUT OF THE USE, REPRODUCTION, MODIFICATION AND/OR DISTRIBUTION# OF THE APPLE SOFTWARE, HOWEVER CAUSED AND WHETHER UNDER THEORY# OF CONTRACT, TORT (INCLUDING NEGLIGENCE), STRICT LIABILITY OR# OTHERWISE, EVEN IF APPLE HAS BEEN ADVISED OF THE POSSIBILITY OF# SUCH DAMAGE.# import sysimport osimport getoptimport subprocessimport plistlibimport operator class UsageException (Exception): &quot;&quot;&quot; Raised when the progam detects a usage issue; the top-level code catches this and prints a usage message. &quot;&quot;&quot; pass class CheckException (Exception): &quot;&quot;&quot; Raised when the &quot;check&quot; subcommand detects a problem; the top-level code catches this and prints a nice error message. &quot;&quot;&quot; def __init__(self, message, path=None): self.message = message self.path = path def checkCodeSignature(programPath, programType): &quot;&quot;&quot;Checks the code signature of the referenced program.&quot;&quot;&quot; # Use the codesign tool to check the signature. The second &quot;-v&quot; is required to enable # verbose mode, which causes codesign to do more checking. By default it does the minimum # amount of checking (&quot;Is the program properly signed?&quot;). If you enabled verbose mode it # does other sanity checks, which we definitely want. The specific thing I&#39;d like to # detect is &quot;Does the code satisfy its own designated requirement?&quot; and I need to enable # verbose mode to get that. args = [ # &quot;false&quot;, &quot;codesign&quot;, &quot;-v&quot;, &quot;-v&quot;, programPath ] try: subprocess.check_call(args, stderr=open(&quot;/dev/null&quot;)) except subprocess.CalledProcessError as e: raise CheckException(&quot;%s code signature invalid&quot; % programType, programPath) def readDesignatedRequirement(programPath, programType): &quot;&quot;&quot;Returns the designated requirement of the program as a string.&quot;&quot;&quot; args = [ # &quot;false&quot;, &quot;codesign&quot;, &quot;-d&quot;, &quot;-r&quot;, &quot;-&quot;, programPath ] try: req = subprocess.check_output( args, stderr=open(&quot;/dev/null&quot;), encoding=&quot;utf-8&quot;) except subprocess.CalledProcessError as e: raise CheckException( &quot;%s designated requirement unreadable&quot; % programType, programPath) reqLines = req.splitlines() if len(reqLines) != 1 or not req.startswith(&quot;designated =&amp;gt; &quot;): raise CheckException( &quot;%s designated requirement malformed&quot; % programType, programPath) return reqLines[0][len(&quot;designated =&amp;gt; &quot;):] def readInfoPlistFromPath(infoPath): &quot;&quot;&quot;Reads an &quot;Info.plist&quot; file from the specified path.&quot;&quot;&quot; try: with open(infoPath, &#39;rb&#39;) as fp: info = plistlib.load(fp) except: raise CheckException(&quot;&#39;Info.plist&#39; not readable&quot;, infoPath) if not isinstance(info, dict): raise CheckException( &quot;&#39;Info.plist&#39; root must be a dictionary&quot;, infoPath) return info def readPlistFromToolSection(toolPath, segmentName, sectionName): &quot;&quot;&quot;Reads a dictionary property list from the specified section within the specified executable.&quot;&quot;&quot; # Run otool -s to get a hex dump of the section. args = [ # &quot;false&quot;, &quot;otool&quot;, &quot;-s&quot;, segmentName, sectionName, toolPath ] try: plistDump = subprocess.check_output(args, encoding=&quot;utf-8&quot;) except subprocess.CalledProcessError as e: raise CheckException(&quot;tool %s / %s section unreadable&quot; % (segmentName, sectionName), toolPath) # Convert that hex dump to an property list. plistLines = plistDump.splitlines() if len(plistLines) &amp;lt; 3 or plistLines[1] != (&quot;Contents of (%s,%s) section&quot; % (segmentName, sectionName)): raise CheckException(&quot;tool %s / %s section dump malformed (1)&quot; % (segmentName, sectionName), toolPath) del plistLines[0:2] try: data = [] for line in plistLines: # line looks like this: # # &#39;0000000100000b80\\t3c 3f 78 6d 6c 20 76 65 72 73 69 6f 6e 3d 22 31 &#39; columns = line.split(&quot;\\t&quot;) assert len(columns) == 2 for hexStr in columns[1].split(): data.append(int(hexStr, 16)) plist = plistlib.loads(bytes(data)) except: raise CheckException(&quot;tool %s / %s section dump malformed (2)&quot; % (segmentName, sectionName), toolPath) # Check the root of the property list. if not isinstance(plist, dict): raise CheckException(&quot;tool %s / %s property list root must be a dictionary&quot; % (segmentName, sectionName), toolPath) return plist def checkStep1(appPath): &quot;&quot;&quot;Checks that the app and the tool are both correctly code signed.&quot;&quot;&quot; if not os.path.isdir(appPath): raise CheckException(&quot;app not found&quot;, appPath) # Check the app&#39;s code signature. checkCodeSignature(appPath, &quot;app&quot;) # Check the tool directory. toolDirPath = os.path.join( appPath, &quot;Contents&quot;, &quot;Library&quot;, &quot;LaunchServices&quot;) if not os.path.isdir(toolDirPath): raise CheckException(&quot;tool directory not found&quot;, toolDirPath) # Check each tool&#39;s code signature. toolPathList = [] for toolName in os.listdir(toolDirPath): if toolName != &quot;.DS_Store&quot;: toolPath = os.path.join(toolDirPath, toolName) if not os.path.isfile(toolPath): raise CheckException( &quot;tool directory contains a directory&quot;, toolPath) checkCodeSignature(toolPath, &quot;tool&quot;) toolPathList.append(toolPath) # Check that we have at least one tool. if len(toolPathList) == 0: raise CheckException(&quot;no tools found&quot;, toolDirPath) return toolPathList def checkStep2(appPath, toolPathList): &quot;&quot;&quot;Checks the SMPrivilegedExecutables entry in the app&#39;s &quot;Info.plist&quot;.&quot;&quot;&quot; # Create a map from the tool name (not path) to its designated requirement. toolNameToReqMap = dict() for toolPath in toolPathList: req = readDesignatedRequirement(toolPath, &quot;tool&quot;) toolNameToReqMap[os.path.basename(toolPath)] = req # Read the Info.plist for the app and extract the SMPrivilegedExecutables value. infoPath = os.path.join(appPath, &quot;Contents&quot;, &quot;Info.plist&quot;) info = readInfoPlistFromPath(infoPath) if &quot;SMPrivilegedExecutables&quot; not in info: raise CheckException(&quot;&#39;SMPrivilegedExecutables&#39; not found&quot;, infoPath) infoToolDict = info[&quot;SMPrivilegedExecutables&quot;] if not isinstance(infoToolDict, dict): raise CheckException( &quot;&#39;SMPrivilegedExecutables&#39; must be a dictionary&quot;, infoPath) # Check that the list of tools matches the list of SMPrivilegedExecutables entries. if sorted(infoToolDict.keys()) != sorted(toolNameToReqMap.keys()): raise CheckException( &quot;&#39;SMPrivilegedExecutables&#39; and tools in &#39;Contents/Library/LaunchServices&#39; don&#39;t match&quot;) # Check that all the requirements match. # This is an interesting policy choice. Technically the tool just needs to match # the requirement listed in SMPrivilegedExecutables, and we can check that by # putting the requirement into tmp.req and then running # # $ codesign -v -R tmp.req /path/to/tool # # However, for a Developer ID signed tool we really want to have the SMPrivilegedExecutables # entry contain the tool&#39;s designated requirement because Xcode has built a # more complex DR that does lots of useful and important checks. So, as a matter # of policy we require that the value in SMPrivilegedExecutables match the tool&#39;s DR. for toolName in infoToolDict: if infoToolDict[toolName] != toolNameToReqMap[toolName]: raise CheckException(&quot;tool designated requirement (%s) doesn&#39;t match entry in &#39;SMPrivilegedExecutables&#39; (%s)&quot; % ( toolNameToReqMap[toolName], infoToolDict[toolName])) def checkStep3(appPath, toolPathList): &quot;&quot;&quot;Checks the &quot;Info.plist&quot; embedded in each helper tool.&quot;&quot;&quot; # First get the app&#39;s designated requirement. appReq = readDesignatedRequirement(appPath, &quot;app&quot;) # Then check that the tool&#39;s SMAuthorizedClients value matches it. for toolPath in toolPathList: info = readPlistFromToolSection(toolPath, &quot;__TEXT&quot;, &quot;__info_plist&quot;) if &quot;CFBundleInfoDictionaryVersion&quot; not in info or info[&quot;CFBundleInfoDictionaryVersion&quot;] != &quot;6.0&quot;: raise CheckException( &quot;&#39;CFBundleInfoDictionaryVersion&#39; in tool __TEXT / __info_plist section must be &#39;6.0&#39;&quot;, toolPath) if &quot;CFBundleIdentifier&quot; not in info or info[&quot;CFBundleIdentifier&quot;] != os.path.basename(toolPath): raise CheckException( &quot;&#39;CFBundleIdentifier&#39; in tool __TEXT / __info_plist section must match tool name&quot;, toolPath) if &quot;SMAuthorizedClients&quot; not in info: raise CheckException( &quot;&#39;SMAuthorizedClients&#39; in tool __TEXT / __info_plist section not found&quot;, toolPath) infoClientList = info[&quot;SMAuthorizedClients&quot;] if not isinstance(infoClientList, list): raise CheckException( &quot;&#39;SMAuthorizedClients&#39; in tool __TEXT / __info_plist section must be an array&quot;, toolPath) if len(infoClientList) != 1: raise CheckException( &quot;&#39;SMAuthorizedClients&#39; in tool __TEXT / __info_plist section must have one entry&quot;, toolPath) # Again, as a matter of policy we require that the SMAuthorizedClients entry must # match exactly the designated requirement of the app. if infoClientList[0] != appReq: raise CheckException(&quot;app designated requirement (%s) doesn&#39;t match entry in &#39;SMAuthorizedClients&#39; (%s)&quot; % ( appReq, infoClientList[0]), toolPath) def checkStep4(appPath, toolPathList): &quot;&quot;&quot;Checks the &quot;launchd.plist&quot; embedded in each helper tool.&quot;&quot;&quot; for toolPath in toolPathList: launchd = readPlistFromToolSection( toolPath, &quot;__TEXT&quot;, &quot;__launchd_plist&quot;) if &quot;Label&quot; not in launchd or launchd[&quot;Label&quot;] != os.path.basename(toolPath): raise CheckException( &quot;&#39;Label&#39; in tool __TEXT / __launchd_plist section must match tool name&quot;, toolPath) # We don&#39;t need to check that the label matches the bundle identifier because # we know it matches the tool name and step 4 checks that the tool name matches # the bundle identifier. def checkStep5(appPath): &quot;&quot;&quot;There&#39;s nothing to do here; we effectively checked for this is steps 1 and 2.&quot;&quot;&quot; pass def check(appPath): &quot;&quot;&quot;Checks the SMJobBless setup of the specified app.&quot;&quot;&quot; # Each of the following steps matches a bullet point in the SMJobBless header doc. toolPathList = checkStep1(appPath) checkStep2(appPath, toolPathList) checkStep3(appPath, toolPathList) checkStep4(appPath, toolPathList) checkStep5(appPath) def setreq(appPath, appInfoPlistPath, toolInfoPlistPaths): &quot;&quot;&quot; Reads information from the built app and uses it to set the SMJobBless setup in the specified app and tool Info.plist source files. &quot;&quot;&quot; if not os.path.isdir(appPath): raise CheckException(&quot;app not found&quot;, appPath) if not os.path.isfile(appInfoPlistPath): raise CheckException(&quot;app &#39;Info.plist&#39; not found&quot;, appInfoPlistPath) for toolInfoPlistPath in toolInfoPlistPaths: if not os.path.isfile(toolInfoPlistPath): raise CheckException( &quot;app &#39;Info.plist&#39; not found&quot;, toolInfoPlistPath) # Get the designated requirement for the app and each of the tools. appReq = readDesignatedRequirement(appPath, &quot;app&quot;) toolDirPath = os.path.join( appPath, &quot;Contents&quot;, &quot;Library&quot;, &quot;LaunchServices&quot;) if not os.path.isdir(toolDirPath): raise CheckException(&quot;tool directory not found&quot;, toolDirPath) toolNameToReqMap = {} for toolName in os.listdir(toolDirPath): req = readDesignatedRequirement( os.path.join(toolDirPath, toolName), &quot;tool&quot;) toolNameToReqMap[toolName] = req if len(toolNameToReqMap) &amp;gt; len(toolInfoPlistPaths): raise CheckException(&quot;tool directory has more tools (%d) than you&#39;ve supplied tool &#39;Info.plist&#39; paths (%d)&quot; % ( len(toolNameToReqMap), len(toolInfoPlistPaths)), toolDirPath) if len(toolNameToReqMap) &amp;lt; len(toolInfoPlistPaths): raise CheckException(&quot;tool directory has fewer tools (%d) than you&#39;ve supplied tool &#39;Info.plist&#39; paths (%d)&quot; % ( len(toolNameToReqMap), len(toolInfoPlistPaths)), toolDirPath) # Build the new value for SMPrivilegedExecutables. appToolDict = {} toolInfoPlistPathToToolInfoMap = {} for toolInfoPlistPath in toolInfoPlistPaths: toolInfo = readInfoPlistFromPath(toolInfoPlistPath) toolInfoPlistPathToToolInfoMap[toolInfoPlistPath] = toolInfo if &quot;CFBundleIdentifier&quot; not in toolInfo: raise CheckException( &quot;&#39;CFBundleIdentifier&#39; not found&quot;, toolInfoPlistPath) bundleID = toolInfo[&quot;CFBundleIdentifier&quot;] if not isinstance(bundleID, str): raise CheckException( &quot;&#39;CFBundleIdentifier&#39; must be a string&quot;, toolInfoPlistPath) appToolDict[bundleID] = toolNameToReqMap[bundleID] # Set the SMPrivilegedExecutables value in the app &quot;Info.plist&quot;. appInfo = readInfoPlistFromPath(appInfoPlistPath) needsUpdate = &quot;SMPrivilegedExecutables&quot; not in appInfo if not needsUpdate: oldAppToolDict = appInfo[&quot;SMPrivilegedExecutables&quot;] if not isinstance(oldAppToolDict, dict): raise CheckException( &quot;&#39;SMPrivilegedExecutables&#39; must be a dictionary&quot;, appInfoPlistPath) appToolDictSorted = sorted( appToolDict.items(), key=operator.itemgetter(0)) oldAppToolDictSorted = sorted( oldAppToolDict.items(), key=operator.itemgetter(0)) needsUpdate = (appToolDictSorted != oldAppToolDictSorted) if needsUpdate: appInfo[&quot;SMPrivilegedExecutables&quot;] = appToolDict with open(appInfoPlistPath, &#39;wb&#39;) as fp: plistlib.dump(appInfo, fp) print(&quot;%s: updated&quot; % appInfoPlistPath, file=sys.stdout) # Set the SMAuthorizedClients value in each tool&#39;s &quot;Info.plist&quot;. # only one element, so obviously sorted (-: toolAppListSorted = [appReq] for toolInfoPlistPath in toolInfoPlistPaths: toolInfo = toolInfoPlistPathToToolInfoMap[toolInfoPlistPath] needsUpdate = &quot;SMAuthorizedClients&quot; not in toolInfo if not needsUpdate: oldToolAppList = toolInfo[&quot;SMAuthorizedClients&quot;] if not isinstance(oldToolAppList, list): raise CheckException( &quot;&#39;SMAuthorizedClients&#39; must be an array&quot;, toolInfoPlistPath) oldToolAppListSorted = sorted(oldToolAppList) needsUpdate = (toolAppListSorted != oldToolAppListSorted) if needsUpdate: toolInfo[&quot;SMAuthorizedClients&quot;] = toolAppListSorted plistlib.writePlist(toolInfo, toolInfoPlistPath) print(&quot;%s: updated&quot; % toolInfoPlistPath, file=sys.stdout) def main(): options, appArgs = getopt.getopt(sys.argv[1:], &quot;d&quot;) debug = False for opt, val in options: if opt == &quot;-d&quot;: debug = True else: raise UsageException() if len(appArgs) == 0: raise UsageException() command = appArgs[0] if command == &quot;check&quot;: if len(appArgs) != 2: raise UsageException() check(appArgs[1]) elif command == &quot;setreq&quot;: if len(appArgs) &amp;lt; 4: raise UsageException() setreq(appArgs[1], appArgs[2], appArgs[3:]) else: raise UsageException() if __name__ == &quot;__main__&quot;: try: main() except CheckException as e: if e.path is None: print(&quot;%s: %s&quot; % (os.path.basename(sys.argv[0]), e.message), file=sys.stderr) else: path = e.path if path.endswith(&quot;/&quot;): path = path[:-1] print(&quot;%s: %s&quot; % (path, e.message), file=sys.stderr) sys.exit(1) except UsageException as e: print(&quot;usage: %s check /path/to/app&quot; % os.path.basename(sys.argv[0]), file=sys.stderr) print(&quot; %s setreq /path/to/app /path/to/app/Info.plist /path/to/tool/Info.plist...&quot; % os.path.basename(sys.argv[0]), file=sys.stderr) sys.exit(1) " }, { "title": "重签名带有特殊权限的应用", "url": "/posts/%E9%87%8D%E7%AD%BE%E5%90%8D%E5%B8%A6%E6%9C%89%E7%89%B9%E6%AE%8A%E6%9D%83%E9%99%90%E7%9A%84%E5%BA%94%E7%94%A8.md/", "categories": "逆向技术", "tags": "macOS逆向, iOS逆向", "date": "2022-06-01 15:40:20 +0800", "snippet": " 获取应用原有的特殊权限 codesign -d --ent :- xxx.app 使用Xcode创建同BundleId的应用并添加相应的权限 比如 iCloudKit权限 编译应用找到embedded.provisionprofile文件拷贝到要签名应用的根目录 把embedded.provisionprofile文件转换成plsit文件 security cms -D -i embedded.provisionprofile &amp;gt; temp.plist/usr/libexec/PlistBuddy -c &quot;Print :Entitlements&quot; temp.plist -x &amp;gt; entitlements.plist 执行重签名 codesign -f -s &quot;证书&quot; --deep --no-strict --entitlements=entitlements.plist xxx.app " }, { "title": "macOS下优雅注入动态库", "url": "/posts/macOS%E4%B8%8B%E4%BC%98%E9%9B%85%E6%B3%A8%E5%85%A5%E5%8A%A8%E6%80%81%E5%BA%93/", "categories": "逆向技术", "tags": "macOS逆向", "date": "2022-05-31 18:28:20 +0800", "snippet": "优雅注入动态库#!/bin/bashAPP_PATH=&quot;`dirname &quot;${0}&quot;`&quot;APP_BIN=&quot;`dirname &quot;${0}&quot;`&quot;/xxx_export DYLD_FORCE_FLAT_NAMESPACE=1export DYLD_INSERT_LIBRARIES=&quot;${APP_PATH}/xxxx.dylib&quot;&quot;$APP_BIN&quot;注入动态库codesign --remove-signature xxxoptool install -c load -p &quot;@loader_path/../../../../Resources/libxxx.dylib&quot; -t xxx" }, { "title": "裸函数的使用", "url": "/posts/%E8%A3%B8%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8/", "categories": "逆向技术", "tags": "macOS逆向, iOS逆向, 安卓逆向", "date": "2022-05-31 18:00:20 +0800", "snippet": "使用裸函数__attribute__((naked)) static int _hook_func() { __asm volatile(&quot;mov x8, 0x1\\n&quot;); __asm volatile(&quot;ret\\n&quot;);}裸函数扩展#if defined(__arm64__) || defined(__aarch64__)#define Naked __attribute__((naked)) static#elif defined(_M_IX86) || defined(__i386__)#define Naked __attribute__((naked)) static#elif defined(_M_X64) || defined(__x86_64__)#define Naked#endif#if defined(__arm64__) || defined(__aarch64__)#define NakedCode(arm64, x86) __asm volatile ( arm64 );#elif defined(_M_IX86) || defined(__i386__)#define NakedCode(arm64, x86) __asm volatile ( x86 );#elif defined(_M_X64) || defined(__x86_64__)#define NakedCode(arm64, x86)#endif#if defined(__arm64__) || defined(__aarch64__)#define NakedReturnCode __asm volatile (&quot;ret\\n&quot;);#elif defined(_M_IX86) || defined(__i386__)#define NakedReturnCode __asm volatile (&quot;ret\\n&quot;);#elif defined(_M_X64) || defined(__x86_64__)#define NakedReturnCode#endif" }, { "title": "Frida使用记录", "url": "/posts/Frida%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/", "categories": "逆向技术", "tags": "macOS逆向, iOS逆向, 安卓逆向", "date": "2022-05-31 18:00:20 +0800", "snippet": "启动应用import fridaimport sysdef on_message(message, data): if message[&#39;type&#39;] == &#39;send&#39;: print(&quot;[*] {0}&quot;.format(message[&#39;payload&#39;])) else: print(message)def start_hook(): # 获得设备管理对象 deviceManager = frida.get_device_manager() # 获得本地设备 device = deviceManager.get_local_device() # 启动应用 app = &#39;#可执行文件路径&#39; pid = device.spawn(app) session = device.attach(pid) # 注入JS脚本 with open(&#39;hook.js&#39;, &#39;r&#39;, encoding=&#39;utf-8&#39;) as f: script = session.create_script(f.read()) script.on(&quot;message&quot;, on_message) script.load() print(&#39;Inject Success&#39;) device.resume(pid) print(&quot;[!] Ctrl+D or Ctrl+Z to detach from instrumented program.\\n\\n&quot;) sys.stdin.read() session.detach()if __name__ == &#39;__main__&#39;: start_hook()HOOK Objective-C方法 setImmediate(function () { //延迟1秒调用Hook方法 setTimeout(start_hook, 1000);}); function start_hook() { //枚举当前加载的模块 const process_Obj_Module_Arr = Process.enumerateModules(); for (const element of process_Obj_Module_Arr) { //包含&quot;lib&quot;字符串的 // if (process_Obj_Module_Arr[i].path.indexOf(&quot;lib&quot;) != -1) { // console.log(&quot;模块名称:&quot;, process_Obj_Module_Arr[i].name); // console.log(&quot;模块地址:&quot;, process_Obj_Module_Arr[i].base); // console.log(&quot;大小:&quot;, process_Obj_Module_Arr[i].size); // console.log(&quot;文件系统路径&quot;, process_Obj_Module_Arr[i].path); // } console.log(&quot;模块名称:&quot;, element.name); console.log(&quot;模块地址:&quot;, element.base); console.log(&quot;大小:&quot;, element.size); console.log(&quot;文件系统路径&quot;, element.path); }} function hookFunction() { var className = &quot;NSUserDefaults&quot;; var funcName = &quot;- stringForKey:&quot;; var hook = eval(&quot;ObjC.classes.&quot; + className + &#39;[&quot;&#39; + funcName + &#39;&quot;]&#39;); Interceptor.attach(hook.implementation, { onLeave: function (retval) { send(&quot;Class Name: &quot; + className); send(&quot;Method Name: &quot; + funcName); send(&quot;Type of return value: &quot; + typeof retval); send(&quot;Original Return Value: &quot; + retval); }, onEnter: function (args) { var className = ObjC.Object(args[0]); var methodName = args[1]; var key = ObjC.Object(args[2]); send(&quot;className: &quot; + className.toString()); send(&quot;methodName: &quot; + methodName.readUtf8String()); send(&quot;key: &quot; + key); var urlString = ObjC.classes.NSString.stringWithString_( &quot;http://www.baidu.com&quot; ); send(&quot;newUrlString: &quot; + urlString.toString()); }, }); C方法 // 获取指定模块ALSR地址var moduleBase = Module.getBaseAddress(&quot;xxxx&quot;); // HOOK C方法var target_addr = moduleBase.add(0xde2e8);Interceptor.attach(target_addr, { onEnter: function (args) { send(&quot;----- HOOK 0xDE2E8 -----&quot;, this.context.x0); // 修改寄存器的值 this.context.x0 = 0x1; }, onLeave: function (retval) { send(&quot;返回值：&quot;, retval); // 替换返回值 retval.replace(ptr(0x1)); },}); // 替换C方法target_addr = moduleBase.add(0xe4bd4);var c_menthod = new NativeFunction(target_addr, &quot;int&quot;, []);Interceptor.replace( c_menthod, new NativeCallback( () =&amp;gt; { send(&quot;----- HOOK 0xE4BD4 -----&quot;); return 0x1; }, &quot;int&quot;, [] )); Java方法 // 字节数组转字符串function bytesToString(bytes) { var javaString = Java.use(&quot;java.lang.String&quot;); return javaString.$new(bytes);} // 打印Java调用栈function printCallStack() { send( Java.use(&quot;android.util.Log&quot;).getStackTraceString( Java.use(&quot;java.lang.Throwable&quot;).$new() ) );} Java.perform(function () { send(&quot;HOOK BEGIN&quot;); // HOOK加解密方法 var Cipher = Java.use(&quot;javax.crypto.Cipher&quot;); var getInstance = Cipher.getInstance.overload(&quot;java.lang.String&quot;); // 初始化方法 用来确定算法 getInstance.implementation = function (algorithm) { send(&quot;getInstance: &quot; + algorithm); return this.getInstance(algorithm); }; var doFinal = Cipher.doFinal.overload(&quot;[B&quot;); // 解密方法 返回解密后的字节数组 doFinal.implementation = function (data) { var jsonBytes = this.doFinal(data); send(&quot;doFinal: &quot; + bytesToString(jsonBytes)); return jsonBytes; }; // HOOK 系统对象转JSON方法 var JSONObject = Java.use(&quot;org.json.JSONObject&quot;); var toString = JSONObject.toString.overload(); toString.implementation = function () { var result = this.toString(); send(&quot;JSONObject.toString: &quot; + result); return result; }; var JSONObject2 = Java.use(&quot;com.alibaba.fastjson.JSONObject&quot;); var toJSONString = JSONObject2.toJSONString.overload(); // HOOK fastjson框架对象转JSON方法 toJSONString.implementation = function () { var result = this.toJSONString(); send(&quot;fastjson.toJSONString: &quot; + result); return result; }; }); " }, { "title": "DNF centos7.X外网架设", "url": "/posts/DNF-centos7.X%E5%A4%96%E7%BD%91%E6%9E%B6%E8%AE%BE/", "categories": "游戏", "tags": "DNF, 架设", "date": "2022-01-10 18:40:20 +0800", "snippet": "DNF CentOS7.X外网架设安装支持库 （CentOS7 64位）yum -y install glibc.i686yum install -y xulrunner.i686yum install -y libXtst.i686yum -y install gcc gcc-c++ make zlib-devel安装数据库yum install -y mysql mysql-server mysql-develwget http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpm &amp;amp;&amp;amp;rpm -ivh mysql-community-release-el7-5.noarch.rpm &amp;amp;&amp;amp;yum install -y mysql mysql-server mysql-devel解压纯端文件 端文件包括了home目录下的GeoIP和dxf、root下面的启动文件run、mysql数据库文件。cd /tar zxvf DNFServer.tar.gz设置对应权限chmod -R 777 /home &amp;amp;&amp;amp;chmod -R 777 /root &amp;amp;&amp;amp;chmod -R 777 /var/lib/mysql &amp;amp;&amp;amp;chown -R mysql.mysql /var/lib/mysql启动数据库 这里注意，还需要修改etc下的my.cnf 文件里的sql_mode 修改为空值 并重启数据库systemctl start mysqld.service编译GeoIPcd /home/GeoIP-1.4.8/./configuremake cleanmake &amp;amp;&amp;amp; make check &amp;amp;&amp;amp; make install更改服务器IPcd /home/dxf/sed -i &quot;s/192.168.200.131/这里写你的外网IP/g&quot; `find . -type f -name &quot;*.tbl&quot;`sed -i &quot;s/192.168.200.131/这里写你的外网IP/g&quot; `find . -type f -name &quot;*.cfg&quot;`挂载虚拟内存 默认大小为8G 有需要可以自己改mkdir /swapdd if=/dev/zero of=/swap/mySwap bs=1M count=8192mkswap /swap/mySwapswapon /swap/mySwapsed -i &#39;$a /swap/mySwap swap swap default 0 0&#39; /etc/fstab修改etc下的ld.so.conf 最下面添加（这个文件是用来自定义lib动态库目录的）把/home/dxf/game文件下的libnxencryption.so文件复制到 /usr/lib目录下复制一个完整的libGeoIP.so.1文件到/usr/lib目录下/usr/lib/usr/lib64/mysql/统一登录器网关 把/usr/lib64/mysql/目录下的。libmysqlclient.so.18 改成libmysqlclient.so.16" }, { "title": "FishHook使用", "url": "/posts/FishHook%E4%BD%BF%E7%94%A8/", "categories": "", "tags": "macOS逆向, iOS逆向, FishHook", "date": "2021-09-03 00:00:00 +0800", "snippet": "FinshHook使用实例// 用于存放系统函数原始实现地址static OSStatus (*orig_SecStaticCodeCheckValidity)(SecCodeRef, SecCSFlags, SecRequirementRef);static OSStatus (*orig_SecStaticCodeCheckValidityWithErrors)(SecStaticCodeRef, SecCSFlags, SecRequirementRef, CFErrorRef);// 替换后的自己的函数声明OSStatus replace_SecStaticCodeCheckValidity(SecCodeRef code, SecCSFlags flags, SecRequirementRef __nullable requirement);OSStatus replace_SecStaticCodeCheckValidityWithErrors(SecStaticCodeRef staticCode, SecCSFlags flags, SecRequirementRef __nullable requirement, CFErrorRef *errors);__attribute__((constructor)) static void initialize() { // Hook系统签名验证函数 rebind_symbols((struct rebinding[2]){ { &quot;SecStaticCodeCheckValidity&quot;, replace_SecStaticCodeCheckValidity, (void *)&amp;amp;orig_SecStaticCodeCheckValidity }, { &quot;SecStaticCodeCheckValidityWithErrors&quot;, replace_SecStaticCodeCheckValidityWithErrors, (void *)&amp;amp;orig_SecStaticCodeCheckValidityWithErrors }, }, 2);}// 自己实现的签名验证函数OSStatus replace_SecStaticCodeCheckValidity(SecCodeRef code, SecCSFlags flags, SecRequirementRef __nullable requirement) { return 0;}OSStatus replace_SecStaticCodeCheckValidityWithErrors(SecStaticCodeRef staticCode, SecCSFlags flags, SecRequirementRef __nullable requirement, CFErrorRef *errors) { return 0;}" }, { "title": "Mac动态库注入方式", "url": "/posts/Mac%E5%8A%A8%E6%80%81%E5%BA%93%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F/", "categories": "", "tags": "macOS逆向", "date": "2021-09-02 01:16:30 +0800", "snippet": " optool 下载 git clone --recursive https://github.com/alexzielenski/optool.git 编译 安装 cp optool /usr/local/bin 注入 optool install -c load -p &quot;@executable_path/libxxx.dylib&quot; -t xxx.app/Content/MacOS/xxx DYLD_INSERT_LIBRARIES " }, { "title": "Reveal", "url": "/posts/Reveal/", "categories": "", "tags": "macOS逆向", "date": "2021-08-28 02:00:30 +0800", "snippet": "31版本 签名验证 00000001000E4BDD call sub_1000CC8C000000001000E4BE2 test dl, 1 ; 签名时间戳验证00000001000E4BE5 jz short loc_1000E4C0D00000001000E4BE7 shl rax, 5 ; 需要修改成mov al, 0x2000000001000E4BEB add rax, [r13+38h]00000001000E4BEF lea rsi, [rbp+var_80]00000001000E4BF3 mov rdi, rax00000001000E4BF6 call sub_100026270 00000001000E4C7A call qword ptr [r14+30h]00000001000E4C7E cmp eax, 100000001000E4C81 mov rax, rbx00000001000E4C84 jz loc_1000E4F4A ; 签名验证关键跳 应用损坏验证 0000000100161306 mov rbx, r120000000100161309 call sub_10044B807000000010016130E test al, al0000000100161310 jnz short loc_10016133A ; 损坏关键跳 注册验证 0000000100385A90 ; =============== S U B R O U T I N E =======================================0000000100385A900000000100385A90 ; Attributes: bp-based frame0000000100385A900000000100385A90 ; char __fastcall sub_100385A90()0000000100385A90 sub_100385A90 proc near ; CODE XREF: sub_100045A00+C9↑p0000000100385A90 ; sub_1000A1780+EF↑p ...0000000100385A900000000100385A90 anonymous_0= byte ptr -18h0000000100385A900000000100385A90 push rbp0000000100385A91 mov rbp, rsp0000000100385A94 push r130000000100385A96 push r120000000100385A98 sub rsp, 40h0000000100385A9C mov rcx, [r13+10h]0000000100385AA0 lea rax, sub_1003893D00000000100385AA7 mov [rbp-30h], rax0000000100385AAB mov [rbp-28h], r130000000100385AAF lea rdi, sub_1003893E00000000100385AB6 lea rdx, byte_10055ED380000000100385ABD lea rax, [rbp-18h]0000000100385AC1 lea rsi, [rbp-40h]0000000100385AC5 mov r13, rcx0000000100385AC8 xor r12d, r12d0000000100385ACB call OS_dispatch_queue.sync&amp;lt;A&amp;gt;(execute:)0000000100385AD0 mov al, [rbp-18h] ; 注册验证 1050000000100385AD3 add rsp, 40h0000000100385AD7 pop r120000000100385AD9 pop r130000000100385ADB pop rbp0000000100385ADC retn0000000100385ADC sub_100385A90 endp " }, { "title": "重签名命令汇总", "url": "/posts/%E9%87%8D%E7%AD%BE%E5%90%8D%E5%91%BD%E4%BB%A4/", "categories": "逆向技术", "tags": "macOS逆向, iOS逆向", "date": "2021-08-27 18:00:20 +0800", "snippet": "应用签名查看应用签名codesign -d -vv xxx.app验证应用签名codesign -vv xxx.app移除应用签名codesign --remove-signature xxx.app应用重签名获取签名证书security find-identity -v -p codesigning重签名codesign -f -s &quot;证书&quot; --deep --no-strict xxx.app重签名frameworkscodesign -f -s &quot;证书&quot; *.framework重签名entitlements应用查看当前应用的entitlementscodesign -d --ent :- xxx.app.provisionprofile文件转entitlements.plistsecurity cms -D -i embedded.provisionprofile &amp;gt; temp.plist/usr/libexec/PlistBuddy -c &quot;Print :Entitlements&quot; temp.plist -x &amp;gt; entitlements.plist重签名应用codesign -f -s &quot;证书&quot; --deep --no-strict --entitlements=entitlements.plist xxx.app" } ]
